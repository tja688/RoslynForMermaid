# 面向模型开发：外部静态分析方案（重构版 / v2）

> 目标一句话：把 Unity 项目里的 C# 代码“持续、低成本地”转成可读的 **L0/L1/L2 架构事实图（Audit）**，再用你喜欢的 **Modern Mermaid** 做呈现与导出。  
> 关键取舍：**事实来源永远是扫描结果 + 明确规则**，Mermaid 只是呈现层。

---

## 0. 背景：我们要保留的能力边界（来自原案，但执行形态改为外部）

原案里你要的能力边界非常清晰：  
- 扫描范围可控；能按“Feature 归属规则”聚合；输出 L0/L1/L2；外部依赖折叠；解析不到也要保守保留并高亮；并最终服务于“定位半径缩短”。
- 边类型与分级（L0 / L1-L2）你已经定义得很接近可执行规范。

**本重构版的变化只有一个：把“Unity Editor 内跑 Roslyn 分析”改为“外部 CLI/服务跑 Roslyn 分析”。**  
Unity 内只做“入口 + 展示 + 交互（可选）”。

---

## 1. 方案选择：为什么外部化更适合你“长期复用 + 工作流迁移”

### 1.1 外部方案的核心优势（你在意的点）
1) **Roslyn 版本可控、可升级**  
Unity 内置/项目内带的 Roslyn 经常被锁死到某个版本（你已经踩到版本冲突导致 MissingMethodException 了），而外部 CLI 可以跟着 .NET/nuget 自由升级。

2) **可复用性天然更强**  
外部工具对“Unity 项目”只是一个目录（加若干约定：asmdef / csproj / defines），同一套工具也能分析：  
- 纯 .NET 解决方案  
- Unity 项目（把 Assets 当源码根）  
- 多项目 mono-repo（按规则拆分 Feature）

3) **更适合做 CI Gate / 快照对比**  
你原案提到“每次合并前生成快照对比”fileciteturn3file0L85-L86，外部方案天然适配：CLI 输出 json/mmd，CI 里 diff 即可。

### 1.2 Unity 内置方案仍然有的“独有优势”（外部很难直接做到）
外部静态分析想做到 **100% 等价于 Unity 编译环境**，会遇到 Unity 特有信息源：
- asmdef 的 Assembly Definition、define constraints、platform constraints  
- Unity 的 Scripting Define Symbols（按平台/构建配置变化）  
- Packages/asmdef 引用链、Unity 特有的程序集注入  
- 资源依赖（Prefab/Scene YAML 引用、Animator Event 字符串、Addressables 等）fileciteturn3file0L115-L119

**解决策略（推荐）**：外部方案先把 C# 事实图做到 80 分稳定；Unity 独有信息作为 *可选增强层*：  
- 先用“字符串拼边/保守 unresolved”满足你的容错诉求（你明确能接受）。  
- 再逐步做“Unity Sidecar 导出编译上下文”给外部工具消费（下面会给出具体落地法）。

---

## 2. 总体架构：三件东西 + 一个可选适配层

### 2.1 组件划分
**A. ArchRadar CLI（必做）**  
- 形态：`dotnet tool` 或普通可执行 CLI（Windows/macOS/Linux）  
- 任务：扫描 → 产出 Audit JSON → 聚合 L0/L1/L2 → 生成 Mermaid 代码（.mmd/.md）

**B. ArchRadar Core（必做）**  
- 纯 C# class library，承载：数据结构、Roslyn 分析、规则引擎、Mermaid 生成器

**C. Modern Mermaid（你指定的渲染器 / 必用）**  
- 你只用它做渲染、导出、主题。它本身是一个 Mermaid 编辑器/预览器，支持多主题、导出、缩放拖拽等。

**D. Unity Adapter（可选，但强烈推荐做成“极薄的一层”）**  
- 只负责：
  - 菜单/按钮：触发 CLI 扫描  
  - 把结果（json/mmd）加载到 UI  
  - （可选）导出 Unity 编译上下文 sidecar.json 给外部 CLI

> 你想要的“点击跳转审计”，外部方案照样能做到：  
> - CLI 输出调用点位置（file/line/column）  
> - Unity 适配层只负责 `AssetDatabase.OpenAsset(MonoScript, line)`

---

## 3. 技术选型（针对 Microsoft.NETCore.App 10.0.1）

### 3.1 .NET / Roslyn 选型
- **TargetFramework**：`net10.0`（你的运行时：Microsoft.NETCore.App 10.0.1）
- **Roslyn**：建议走 NuGet 的现代版本（不要再碰 Unity 内置/项目内旧 DLL 混用）
  - `Microsoft.CodeAnalysis.CSharp`
  - `Microsoft.CodeAnalysis.Workspaces.MSBuild`（如果你选择“加载 .sln/.csproj”）
  - `Microsoft.Build.Locator`（MSBuildWorkspace 需要定位 MSBuild）
- **CLI 参数解析**：`System.CommandLine`（可选）
- **序列化**：`System.Text.Json`（够用，强烈建议定义稳定 schema）

> 关键纪律：**不要把 Unity 项目里自带的 `Microsoft.CodeAnalysis*.dll` 复制到外部工具引用**。外部工具只认 NuGet 管理的版本，避免你之前那种 API 缺失/方法找不到。

### 3.2 Mermaid 渲染：Modern Mermaid 的接入方式（两种都支持）
Modern Mermaid 是一个“在线/本地都能跑”的 Mermaid 编辑器：  
- 它有在线体验地址，也可以本地起服务（Node + pnpm）。
- 功能侧：多主题、导出 PNG/JPG、缩放/拖拽、自动缩放等。

**方案 1（最快落地，推荐先用）**：CLI 只输出 `.mmd` / `.md`，你把内容粘贴/导入到 modern-mermaid.live 渲染导出。  
**方案 2（更像“工作流产品”）**：本地部署 modern_mermaid，做一个“Import .mmd / Import audit.json → 自动生成视图”的小扩展。

Modern Mermaid 的 Quick Start（本地跑起来）在仓库 README 给了 node + pnpm 的步骤。

---

## 4. 产物与目录规范（把“事实来源”做成可沉淀的资产）

每次扫描输出一个 **Snapshot**（方便 diff、回滚、喂给 AI）：
```
/.archradar/
  /snapshots/
    2025-12-25_1412/
      audit.json                # 事实图（全量节点/边/调用点）
      lint.json                 # （可选）规则违规结果
      L0.mmd                    # L0 mermaid
      L1_featureA.mmd           # L1（按 feature 拆文件）
      L2_featureA_ControllerX.mmd# L2（按选中脚本/入口拆）
      index.json                # 快照元信息（scan config + git hash + stats）
  config.json                   # 扫描配置（规则/分组/过滤/降噪）
```

### 4.1 Audit JSON（事实图）建议 schema（稳定、可扩展）
- Node
  - `id`（稳定：建议用 `assembly|namespace|type` 或 `filePath#typeName`）
  - `kind`：`Feature | Controller | System | Model | Command | Query | Event | Repo | Factory | External | Unresolved`
  - `nameDisplay`（“原命名 + 中文括注”你之前也强调过这种可读性习惯）
  - `featureKey`（Feature 归属）
  - `source`：`{ file, startLine, startCol }`（可空）
- Edge
  - `fromId` / `toId`
  - `edgeKind`：`UsesType | Calls | Subscribes | Creates | IO | FrameworkInferred`
  - `weight`：用于 L0 的“依赖强度”统计
  - `callSites`：`[{ file, line, col, snippet? }]`（可选，先不强求 snippet）
  - `confidence`：`High | Medium | Low`（Low 常用于 Unresolved/字符串推断）

> 你原案的边类型定义非常可执行，直接沿用即可。

---

## 5. 扫描配置（你要的“规则”落点在这里，不要写死在代码里）

`config.json` 关键字段建议：
- `roots`: 扫描根目录（如 `Assets/Scripts/Features`）
- `excludeGlobs`: `**/Tests/**`, `**/Editor/**`, `**/*Generated*` ...
- `featureRules`（Feature 归属规则）
  - `byNamespacePrefix`: `ThatGameJam.Features.<FeatureName>.` → featureKey = `<FeatureName>`
  - `fallbackByFolder`: `Assets/Scripts/Features/<FeatureName>/...`
- `bucketRules`（L1 分桶规则）
  - `Controllers`：命名 `*Controller` 或 namespace contains `.Controllers`
  - `Systems`：`*System` / `.Systems`
  - `Models`：`*Model` / `.Models`
  - `Commands`：继承/实现 `ICommand` 或命名 `*Command`
  - `Queries`：`*Query`
  - `Events`：`*Event`
  - 其余：`Infrastructure/Adapters/External`
- `ioWhitelist`（IO 白名单）
  - `System.IO.*`, `UnityEngine.PlayerPrefs`, `UnityWebRequest` 等（先粗粒度）
- `externalFolding`
  - `foldUnityNamespaces`: `UnityEngine`, `UnityEditor`, `Unity.*`
  - `foldThirdPartyNamespaces`: `Spine`, `Cysharp`, `DG.Tweening` ...

---

## 6. Roslyn 分析管线（实现细节：怎么从代码拿到“事实边”）

> 这里按“可落地的 80 分”设计：先让你稳定产图、可用；再逐步把语义精度提高。

### 6.1 两种解析模式（你可以二选一，甚至同时支持）

#### 模式 A：Directory-only（最快，最少环境依赖，推荐先跑通）
- 直接枚举 `.cs` 文件 → `CSharpSyntaxTree.ParseText`
- 只做 Syntax 级别：
  - `UsesType`：字段/参数/基类/接口/泛型的“语法名字”
  - `Calls`：InvocationExpression 的 `IdentifierName`/`MemberAccessExpression` 文本
  - 很多边会是 `Unresolved` 或 `External`（但你能接受“字符串拼边”）

优点：0 msbuild 依赖、跨平台稳定、不会被 Unity 编译环境卡死。  
缺点：精确度一般（尤其是重载、using alias、泛型实例）。

#### 模式 B：MSBuildWorkspace（语义更强，适合做“越权依赖”判定）
- 用 `MSBuildWorkspace.OpenSolutionAsync(pathToSln)`  
- 对每个 `Document`：拿 `SemanticModel`，把符号解析到 `ISymbol`  
- 这样 `Calls/UsesType` 能落到稳定的 `ContainingType`，误报会大幅下降

前置：机器上要有可用的 MSBuild（通常随 VS / Build Tools）。

### 6.2 边类型提取（推荐实现顺序）

**Step 1：UsesType（类型引用）** 
从以下位置收集：  
- 字段类型：`FieldDeclarationSyntax.Declaration.Type`
- 属性类型：`PropertyDeclarationSyntax.Type`
- 参数类型：`ParameterSyntax.Type`
- 返回类型：`MethodDeclarationSyntax.ReturnType`
- 继承/实现：`BaseListSyntax.Types`
- 泛型参数：`GenericNameSyntax.TypeArgumentList`

落地策略：  
- 有 SemanticModel：用 `GetTypeInfo` / `GetSymbolInfo` → 归一化到 `INamedTypeSymbol`  
- 没有语义：用 `.ToString()` 做 “best effort”，并标 `confidence=Low`

**Step 2：Calls（调用）** 
抓 `InvocationExpressionSyntax`：  
- 语义模式：`semanticModel.GetSymbolInfo(invocation).Symbol` → `IMethodSymbol.ContainingType`  
- 语法模式：
  - `invocation.Expression` 若是 `IdentifierNameSyntax` → “函数名”  
  - 若是 `MemberAccessExpressionSyntax` → “左侧表达式文本 + 右侧 name”

同时记录 CallSite（文件/行/列），这是你后续“缩短排查半径”的核心。fileciteturn3file0L57-L62

**Step 3：Subscribes（事件订阅）** 
抓 `AssignmentExpressionSyntax`：  
- `+=`（AddAssignmentExpression）  
- 语义模式：`GetSymbolInfo(left).Symbol` 若是 `IEventSymbol` → toId = event type/declaring type  
- 语法模式：left 文本保守记录，标 `Low`

**Step 4：Creates（创建）**
抓：  
- `ObjectCreationExpressionSyntax` (`new T(...)`)  
- `ImplicitObjectCreationExpressionSyntax` (`new(...)`)  
- 可选：识别 `Activator.CreateInstance` / 工厂方法（先按白名单关键字）

**Step 5：IO（I/O 行为）**
白名单策略：  
- 如果 Invocation 的 `ContainingNamespace` 命中白名单 → edgeKind=IO  
- 没语义时：用文本匹配（`File.`/`Directory.`/`PlayerPrefs.`/`UnityWebRequest`）

**Step 6：FrameworkInferred（框架推断）**  
用于 QFramework 的“注册点推断/生命周期推断”，你原案已经把它留作可选。
建议实现方式：  
- 配置驱动：在 config.json 里列出“注册 API”签名关键词（如 `RegisterSystem<...>`）  
- 扫 Invocation：命中则生成推断边（confidence=Medium）

### 6.3 从事实图聚合出 L0/L1/L2
- **L0（Feature 依赖图）**：按 `featureKey` 折叠 Node；Edge weight = 跨 Feature 的边数量或调用点数量。fileciteturn3file0L37-L42
- **L1（Feature 内结构图）**：按 bucketRules 分桶，画桶内节点（可降噪：只保留跨桶边/关键节点边）。fileciteturn3file0L43-L48
- **L2（脚本聚焦图）**：以某个脚本为中心：  
  - Inbound Callers（跨 Feature / 外部）  
  - 该脚本的入口方法列表  
  - “到某类节点为止截断”策略（你举例里是 stop at Command）。fileciteturn3file0L49-L56

---

## 7. Mermaid 生成与 Modern Mermaid 工作流

### 7.1 Mermaid 输出约束（建议你继续坚持）
- L0：只画 Feature 级节点 + 两类边：
  - `Internal & External Calls`
  - `Data & Storage I/O`fileciteturn3file0L135-L159
- L1/L2：用你定义的 typed edges：`UsesType / Calls / Subscribes / Creates / IO ...`fileciteturn3file0L131-L132
- Unresolved：高亮（classDef unresolved），保守保留。fileciteturn3file0L55-L56

### 7.2 Modern Mermaid 使用方式（推荐工作流）
- 先把 `.mmd` 文件丢进 Modern Mermaid（在线或本地）进行：主题选择、缩放拖拽、导出 PNG/JPG。  
Modern Mermaid 在 README 里明确提供了多主题、导出、缩放拖拽等能力。citeturn2view0

> 如果你后续要“自动化导出”，那属于第二阶段：  
> - 让 modern_mermaid 本地跑起来（Node 20+），你用脚本/本地服务去驱动它的导出能力（需要进一步读源码定位导出入口）。citeturn2view0

---

## 8. 最小验证：一个 CLI 程序跑通“解析 + 事实边 + L0 Mermaid”

> 这个验证用 Directory-only 模式，不依赖 MSBuild，**只要 .NET 10 能跑**。  
> 你可以先用它确认：Roslyn 包版本正确、能解析语法树、能导出 mermaid。  
> 等确认 OK 了，再加 MSBuildWorkspace 提升精度。

### 8.1 创建项目（建议命令）
```bash
dotnet new sln -n ArchRadar
dotnet new classlib -n ArchRadar.Core
dotnet new console -n ArchRadar.Cli

dotnet sln add .\ArchRadar.Core\ArchRadar.Core.csproj
dotnet sln add .\ArchRadar.Cli\ArchRadar.Cli.csproj

dotnet add .\ArchRadar.Core package Microsoft.CodeAnalysis.CSharp
dotnet add .\ArchRadar.Cli  reference .\ArchRadar.Core\ArchRadar.Core.csproj
```

### 8.2 验收标准（最小验证）
你只需要看到三件事：
1) CLI 能跑完并输出 `.mmd`  
2) Modern Mermaid 能正确渲染（能缩放拖拽、换主题、导出）
3) `.mmd` 里出现的 Calls 边大体符合直觉（允许很多是 Unresolved/粗糙）

---

## 9. 实现阶段（分阶段交付，保证每一步都能“立即用起来”）

### Phase 0：PoC（1-2 天级）
- 把基础的扫描跑起来，别报错

### Phase 1：可用的事实图（Audit v1）
- 加入：稳定 schema 的 `audit.json`
- 完成：UsesType / Calls / Subscribes / Creates / IO（先语法级 best-effort）
- 加入：Feature 归属规则（namespace/folder），让 L0 真正变成 Feature 图
- 输出：L0.mmd + L1（按 feature 输出多个文件）

### Phase 2：精度升级（语义化 + 降噪）
- 引入 MSBuildWorkspace（可选开关），让 Calls/UsesType 尽量落到符号级
- 做降噪：
  - 同一条边合并 callSites
  - 外部依赖折叠（Unity / 3rd-party 聚合节点）
- 输出：L2（脚本聚焦）支持 “stop at Command/Query/Event” 的截断策略

### Phase 3：Unity 适配层（薄壳）
- Unity 菜单：`Tools/ArchRadar/Scan`  
- 点击后：调用外部 CLI，读取 `.archradar/snapshots/latest/...`
- UI：Tree View（L0 → L1 → L2），点击条目打开 `.mmd`（或直接嵌入 WebView）
- 跳转：选择某条 edge → 列出 callSites → 点击打开源码行（从 Tree View 跳即可，先不做“点图跳转”）

### Phase 4：规则检查（Lint / CI gate）
- 你原案里已经描述得很明确：写规则、出报告、生成违规子图
- 做法：
  - `lintRules.json`（规则配置）
  - CLI 输出 `lint.json` + `violations.mmd`（只画违规边）
  - CI：对比 lint.json，超阈值 fail

---

## 10. 最终验收标准（对齐原案，但形态外部化）
- 一条命令（或 Unity 菜单）生成：L0/L1/L2 三层图
- 外部依赖折叠；Unresolved 保守保留并高亮
- 发现异常依赖时：能从边拿到 callSites，1-2 次点击打开到源码行
- Mermaid 用 Modern Mermaid 呈现与导出（主题/导出/缩放拖拽能力明确支持）

---