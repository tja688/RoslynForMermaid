第二阶段设计案 v3

技术选型：.NET 后端（常驻） + 自研 Web 前端（frontend-ui）
前端视觉底座：Vendor Copy Modern Mermaid（仅 Preview 渲染引擎 + themes/backgrounds/fonts + export/panzoom 能力）

0. 版本变更摘要（v2 → v3）
0.1 保持不变（沿用 v2 决策）

存储：JSON-only（catalog/index/meta/config），不引入 DB。



Snapshot 输出：Workspace-only，强制工具内部路径，不允许用户指定外部输出目录。



点击方案：UI 渲染后绑定交互（不依赖在 .mmd 里写 click 语句作为主实现），并把坑位规避与验收写死。



0.2 核心变更（从“Fork Modern Mermaid” → “切 Preview 引擎 + 新前端”）

v2 前端策略是“直接 Fork Modern Mermaid 并在其上实现工作台”。



v3 改为：前端由我们自己的 frontend-ui 承载，Modern Mermaid 只作为“渲染引擎与主题资产来源”，通过 vendor copy 的方式引入（切蛋糕方案 A）。

结果：前端工程显著变轻，AI 开发压力更低；同时你最在意的 多主题/背景/字体/导出/缩放拖拽 仍可保留为底座能力（来自切出来的 Preview）。



1. 第二阶段目标（v3）
1.1 总目标

把你现有扫描产物（audit.json + L0/L1/L2 + lint.json(可选)）沉淀为可管理的 Snapshot 资产，并在 frontend-ui 中实现：

项目/快照管理：选择项目 → 查看历史快照 → 打开某快照的 L0/L1/L2 图



稳定交互导航：L0 → L1 → L2 点击跳转、Inspector 详情、边类型筛选



定位半径缩短：从边/节点 → callsites 列表 → 一键打开源码定位（由 .NET 后端执行）



（预留）lint overlay：承载 lint.json 并高亮违规、定位链路跑通（为后续阶段铺路）



1.2 非目标（v3 明确不做）

不做 DB 部署/迁移/复杂查询语言（保持 v2）。



不做“输出到用户指定目录”（保持 v2）。



不做“复刻完整 Modern Mermaid 编辑器/分享/多语言/PWA 等产品功能”（v3 只复用 Preview + 主题资产能力）。

2. 资产与存储（JSON-only + Workspace-only）

本节完全沿用 v2，只把“谁来消费这些资产”从 Modern Mermaid fork 改成 frontend-ui。

2.1 Workspace-only 路径规范（强制内置）

继续沿用外部方案目录结构，但根目录强制为工具 workspace（例如 ~/.archradar/ / %AppData%/ArchRadar/），不接受外部输出路径配置。



目录示意（保持 v2）：

snapshots/<timestamp>/audit.json

snapshots/<timestamp>/L0.mmd / L1_*.mmd / L2_*.mmd



snapshots/<timestamp>/index.json（scan 参数快照 + 统计摘要）



snapshots/<timestamp>/lint.json（可选）



2.2 JSON 数据管理（无 DB）

后端维护三类 JSON（保持 v2）：workspace catalog、project profile、snapshot index，并要求“写临时文件→原子替换”。



3. 系统架构（v3：后端服务 + 自研前端 + Preview 引擎切片）
3.1 后端（.NET 常驻服务）

职责保持 v2：扫描调度、Snapshot 写入 workspace、catalog/profile CRUD、Open-in-Editor。



v3 需要新增/明确的两点（面向新前端接入）：

静态资源托管方式（2 选 1）

同进程托管（推荐生产态）：.NET 直接 serve frontend-ui 的 build 产物（单端口：UI + API）。

分端口托管（推荐开发态）：前端 pnpm dev，后端独立端口；前端通过 VITE_API_BASE 或 dev proxy 访问 API。

API 形态稳定化

前端不再“读 workspace 文件系统”，而是只认后端 API（减少跨平台/权限/路径问题，也方便你以后做 diff、lint overlay 等）。

3.2 前端（frontend-ui：自研工作台 + Preview 引擎切片）

v3 前端由你新建并已跑通的 frontend-ui 承载（React + Vite + Tailwind）。
Modern Mermaid 在 v3 中不再作为“整个产品前端”，而是被降级为：

主题/背景/字体资产（themes/backgrounds/fonts/fonts.css）

Mermaid Preview 渲染引擎（mermaid.render → SVG 注入 → pan/zoom → export）
这些能力以 vendor copy 形式引入，作为“可视化底座”，不携带 Modern Mermaid 的编辑器、布局、分享等重功能模块。



4. 点击/跳转方案（v3：坚持 UI 后绑，且写死验收）

本节原则与 v2 完全一致（只是绑定代码落在 MermaidPreview 组件内）。

4.1 生成侧：节点稳定 ID（仍然必须改）

.mmd 中每个节点必须可定位到稳定 nodeId（建议复用 audit 的稳定 id）。



nodeId 必须做 Mermaid 兼容字符规范化，避免渲染后 DOM 找不到。



4.2 渲染侧：绑定纪律（防“点击丢失/错绑”）

每次重新渲染 SVG 后必须重新 bind（切主题/切图/重新 layout 都是“重渲染”）。



绑定目标必须基于 SVG 中可识别的 nodeId 标记；禁止靠“渲染后文本匹配”。



4.3 v3 点击验收（硬验收保持 v2）

L0 双击 Feature → 必定进入对应 L1；L1 双击节点 → 必定进入对应 L2。



任意切主题/缩放拖拽/导出后，返回视图点击仍然有效（重渲染不丢）。



点击边能展示 edgeKind 与 callsites；点击 callsite 能触发打开源码定位。



5. Modern Mermaid “切片接入”计划（v3 重点：搬什么、怎么接、接入边界）

v2 的这一节叫 “Fork 改造计划”，现在改为“切片接入计划”：只搬底座能力，不背整套应用。



5.1 需要 vendor copy 的能力清单（必须搬）

来自 Modern Mermaid 的底座体验（你最看重的）：

主题/背景/整体视觉（官网风格）



画布缩放拖拽、自动 fit



导出 PNG/JPG/SVG（至少保留一种）



Mermaid 解析错误提示与预览稳定性



5.2 切片接入边界（明确不搬）

不搬 Modern Mermaid 的 Layout（编辑器双栏）、URL 分享、多语言、PWA 缓存、Analytics 等。

不把“编辑器能力”作为阶段目标（最多只做只读 code viewer 兜底）。



5.3 在新前端中的落位（组件/模块职责）

MermaidPreview：渲染 + pan/zoom + export +（未来）bind 点击入口

ThemeCatalog：主题/背景/字体选择、持久化（localStorage 级别即可）

Workspace UI：项目/快照/层级树、筛选器、Inspector、callsites 列表

ApiClient：所有后端交互集中封装（避免散落 fetch）

6. 阶段拆解与验收（v3：围绕 frontend-ui 交付）

v2 的 Stage A–E 框架可继续沿用，但把“在 Modern Mermaid fork 上实现”改成“在 frontend-ui 上实现”，并把“切片引擎落地”作为 Stage A 的第一子目标。



Stage A：Viewer MVP（切片引擎落地 + Snapshot Viewer）

目标

frontend-ui 跑起来（开发态）

Preview 引擎切片接入成功：主题/缩放/导出不退化

连接后端，加载 workspace 内 latest snapshot，能渲染 L0/L1/L2



验收

L0/L1/L2 任意切换渲染成功



导出成功（至少一种格式）



主题/缩放拖拽可用且稳定



Stage B：点击导航闭环（重渲染不丢交互）

目标

节点稳定 ID 打通

UI 后绑交互完成：单击/双击/右键/筛选

重渲染（切主题/切图/重新 layout）后交互仍可用



验收

L0 → L1 → L2 下钻链路稳定



“切主题后再点击”不失效（硬验收）



Stage C：Open-in-Editor 闭环

目标/验收（保持 v2）

callsite 列表与打开源码定位链路跑通



Stage D：历史快照浏览（JSON catalog）

目标/验收（保持 v2）

同一项目可列出 N 次扫描并回看任意一次（无需重跑扫描）



Stage E：lint overlay 承载（预留但建议做最小闭环）

目标/验收（保持 v2）

能显示违规并定位到图上/源码



7. 后端如何接入新前端（v3 的“无负担对接”原则）

v3 的关键是：前端完全不关心 workspace 目录结构，只认 API；后端则保持你 v2 的 workspace/catelog/profile/snapshot 管理职责不变。



建议后端提供（最小闭环）能力集合：

projects：列出项目、创建/更新 project profile

snapshots：列出项目下 snapshot，读取 snapshot index

diagrams：按 layerKey 返回对应 .mmd 文本（L0 / L1(feature) / L2(script)）

audit：按需返回 audit 子集（用于 Inspector、callsites）

open-in-editor：接收 file/line/col 并在本机编辑器定位（前端只发请求）