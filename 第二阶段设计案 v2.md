第二阶段设计案 v2
技术选型：.NET 后端（常驻） + Modern Mermaid（Fork 后作为前端）
0. 版本变更摘要（v1 → v2）

存储：只用 JSON（catalog/index/meta/config），不引入 SQLite/LiteDB 等 DB。

Snapshot 输出：强制工具内部路径（Workspace-only），不允许用户指定外部输出目录。

点击方案：继续采用“UI 渲染后绑定交互”（不依赖在 .mmd 里写 click 语句作为主实现），但会补齐必要的“坑位规避”与验收标准（见第 4 节）。

面向模型开发工具_v1_可视化构建

面向模型开发工具_v1_可视化构建

前端：直接 Fork Modern Mermaid 并改造——所有原先 WorkBench 的 UI 目标，改为“在 Modern Mermaid 上实现”，本阶段只把“要做成什么样”计划清楚；你后续再把项目扒下来读架构后决定具体重构粒度。

面向模型开发构想_v2_外部方案

1. 第二阶段目标（v2）
1.1 总目标

把你现有扫描产物（audit.json + L0/L1/L2 + lint.json(可选)）沉淀为可管理的 Snapshot 资产

面向模型开发构想_v2_外部方案

，并在 Modern Mermaid（fork） 里实现：

项目/快照管理：选择项目 → 查看历史快照 → 打开某快照的 L0/L1/L2 图

稳定交互导航：L0 → L1 → L2 点击跳转、Inspector 详情、边类型筛选

定位半径缩短：从边/节点 → callsites 列表 → 一键打开源码定位（由 .NET 后端执行）

（预留）lint overlay：能承载 lint.json 并把违规高亮、定位链路跑通（为后续 Phase4 铺路）

面向模型开发工具_v1_可视化构建

1.2 非目标（v2 明确不做）

不做 DB 部署/迁移/复杂查询语言

不做“输出到用户指定目录”

不做“完整 UI 自研重写”（Modern Mermaid 承载全部前端）

2. 资产与存储（JSON-only + Workspace-only）
2.1 Workspace-only 路径规范（强制内置）

继续沿用你外部方案里的 Snapshot 目录结构，但根目录强制为工具 workspace（例如 ~/.archradar/ / %AppData%/ArchRadar/），不接受外部输出路径配置。目录示意与内容保持一致：

面向模型开发构想_v2_外部方案

snapshots/<timestamp>/audit.json（事实图）

snapshots/<timestamp>/L0.mmd / L1_*.mmd / L2_*.mmd

snapshots/<timestamp>/index.json（本次扫描配置快照、统计信息）

snapshots/<timestamp>/lint.json（可选）

2.2 JSON 数据管理（无 DB）

后端维护三类 JSON：

workspace catalog（全局）

记录：项目列表（projectId、projectRoot、显示名）、最近打开、快照列表索引、标签等

目标：支撑“增删改查快照/项目”的管理能力，足够即可（不追求复杂查询）

project profile（每项目）

记录：项目 root、默认扫描入口（sln/目录）、默认 ruleset、过滤/降噪策略等（你现有 CLI 已支持这些配置能力，v2 只是把它产品化存下来）

面向模型开发构想_v2_外部方案

snapshot index（每快照）

记录：本次 scan 参数快照 + 摘要统计（nodes/edges/violations 数等）

一致性要求（验收会用到）：

所有 JSON 写入必须“先写临时文件，再原子替换”，保证断电/崩溃不破坏 catalog（这是 JSON-only 模式的底线）。

3. 系统架构（v2：后端服务 + Modern Mermaid fork 前端）
3.1 后端（.NET 常驻服务）

职责仍与 v1 类似，但去掉 DB 相关内容，强化 workspace-only：

扫描调度：调用你现有 Core/CLI（同进程或子进程均可，计划层不约束实现）

Snapshot 资产写入：强制写入 workspace

Catalog/Profiles 的 JSON 管理：项目/快照增删改查

Open-in-Editor：根据 callsites（file/line/col）在本机编辑器打开定位（由后端执行，前端只发请求）

3.2 前端（Modern Mermaid fork）

Modern Mermaid 在你方案里被定位为可本地跑的 Mermaid 编辑器/渲染器，并具备多主题、导出、缩放拖拽等能力

面向模型开发构想_v2_外部方案

。v2 选择 fork 它作为主前端，因此前端的计划目标变为：

保留其渲染/主题/导出/缩放拖拽能力作为“基础体验底座”

在其基础上新增“模型开发工作台”能力（项目/快照/层级/交互/打开源码）

4. 点击/跳转方案（v2：坚持 UI 后绑，但把坑位写进计划与验收）

你 v1 方案里已经明确“渲染 SVG → 挂载交互”两段式

面向模型开发工具_v1_可视化构建

，并且要求“节点稳定 ID”作为点击根基

面向模型开发工具_v1_可视化构建

。v2 保持不变，但把“容易踩坑的点”固化为必须实现的工程纪律：

4.1 生成侧：节点稳定 ID（仍然必须改）

每个节点在 .mmd 中必须可定位到一个稳定 nodeId（来源建议直接复用 audit 的稳定 id）

面向模型开发工具_v1_可视化构建

nodeId 做 Mermaid 兼容字符规范化（避免渲染后 DOM 找不到）

面向模型开发工具_v1_可视化构建

4.2 渲染侧：绑定纪律（防“点击丢失/错绑”）

每次重新渲染 SVG 后必须重新 bind（任何 filter / 主题切换 / 重新 layout 都视为“重渲染”）

绑定目标来源必须是“SVG 中可识别的 nodeId 标记”，禁止用“渲染后文本匹配”这种脆弱方式

点击语义分层（沿用 v1 的交互规范）：单击选中、双击下钻、右键菜单、callsite 点击打开源码

面向模型开发工具_v1_可视化构建

4.3 v2 点击验收（新增）

在 L0 双击 Feature 能稳定进入对应 L1；在 L1 双击节点能进入对应 L2（同 v1）

面向模型开发工具_v1_可视化构建

任意切主题/缩放拖拽/导出后，返回视图点击仍然有效（“重渲染后交互不丢”是 v2 的硬验收）

点击边能展示 edgeKind 与 callsites 列表；点击 callsite 能打开源码定位（同 v1，但强调“重渲染不丢”）

面向模型开发工具_v1_可视化构建

5. Modern Mermaid Fork 改造计划（v2 重点：只写“要做成什么样”）

这一节不写你具体要改哪几个文件、怎么重构——按你要求，本阶段只把目标拆清楚；你后续把 Modern Mermaid 项目扒下来读完结构再决定“轻改/大改”。

5.1 保留能力清单（不动或尽量少动）

来自 Modern Mermaid 的“底座体验”（你明确非常看重）：

主题/背景/整体视觉（你喜欢的官网效果）

画布缩放拖拽、自动 fit

导出 PNG/JPG/SVG（若原项目支持）

Mermaid 解析错误提示与预览稳定性

v2 的目标是：这些能力继续存在，并且不因我们加工作台功能而退化。

面向模型开发构想_v2_外部方案

5.2 新增能力清单（我们要在 fork 上加的）

Workspace 模式入口

一个“ArchRadar / Workspace”入口页：用于连接本地 .NET 后端，加载项目列表与快照列表

项目与快照浏览

左侧新增（或用抽屉/侧栏形式）：

Project 列表（最近/收藏）

Snapshot 时间线（latest/历史/标签）

图层级树（L0 → L1(feature) → L2(script focus)）

从 Snapshot 加载 Mermaid

让 Modern Mermaid 的“输入来源”从纯编辑器文本扩展为：

从后端拉取 .mmd 内容

一键切换 L0/L1/L2 文件

保留“编辑器模式”作为高级功能（可选）：允许你临时修改/实验图，但不影响 snapshot 原件

Inspector 面板

选中节点/边后，侧栏显示：

node: kind、featureKey、source file/line、是否 unresolved

edge: edgeKind、weight、callsites 列表
（这些字段来自你的 audit schema 方向

面向模型开发构想_v2_外部方案

）

Open-in-Editor

callsite 点击 → 请求后端 → 打开编辑器定位

失败兜底：在前端打开“只读代码预览”（是否采用 Modern Mermaid 原编辑器区域作为预览承载，由你读源码后决定）

（预留）lint overlay

当 snapshot 有 lint.json 时：

图上高亮违规节点/边

右侧展示违规列表

点击违规项可定位/打开源码（与 v1 的 Stage E 对齐）

面向模型开发工具_v1_可视化构建

6. 阶段拆解与验收（v2 版：围绕 Modern Mermaid fork 交付）

沿用 v1 的 Stage A-E 框架

面向模型开发工具_v1_可视化构建

，但把“自研 WorkBench 前端”的表述全部替换为“在 Modern Mermaid fork 上实现”。

Stage A：Fork 落地 + Snapshot Viewer MVP

目标

Modern Mermaid 能作为你的前端跑起来

连接后端，加载 workspace 内 latest snapshot，能渲染 L0/L1/L2

保留 Modern Mermaid 的主题/缩放/导出体验不退化

面向模型开发工具_v1_可视化构建

验收

L0/L1/L2 任意切换渲染成功

导出成功（至少一种格式）

主题/缩放拖拽可用且稳定

Stage B：点击导航闭环（重渲染不丢交互）

目标

节点稳定 ID 打通

面向模型开发工具_v1_可视化构建

UI 后绑交互完成：单击/双击/右键/筛选

重渲染（切主题/切图/重新 layout）后交互仍可用

验收

L0 → L1 → L2 下钻链路稳定

面向模型开发工具_v1_可视化构建

“切主题后再点击”不失效（v2 新增硬验收）

Stage C：Open-in-Editor 闭环

目标

callsite 列表与打开源码定位链路跑通

面向模型开发工具_v1_可视化构建

验收

从 L2 的 callsite 点击可打开编辑器定位

失败兜底可预览代码

Stage D：历史快照浏览（JSON catalog）

目标

catalog.json 支撑：项目/快照增删改查、标签、基线选择（不做 diff 也要先把“历史管理”跑通）

验收

同一项目可列出 N 次扫描并回看任意一次（无需重跑扫描）

Stage E：lint overlay 承载（预留但建议做最小闭环）

目标/验收

与 v1 Stage E 一致：能显示违规并定位到图上/源码

面向模型开发工具_v1_可视化构建

7. 你后续“扒 Modern Mermaid 源码”时，最先确认的 5 件事（作为 v2 的落地前置清单）

这不是实现建议，只是你读项目结构时的“勘探 checklist”，避免开改后推翻：

Mermaid 渲染入口在哪里（集中式 render service 还是散落在组件里）

主题/背景切换机制是怎么组织的（配置驱动还是硬编码）

导出能力的实现边界（是否依赖 canvas/svg 的某种转换链路）

是否已有 pan/zoom 封装（以及是否会导致“重渲染后 DOM 替换”）

现有编辑器数据流（文本 → render）如何替换为（snapshot mmd → render）